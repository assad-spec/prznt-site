<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thought Tree — Prznt</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400&family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg:    #FAF9F6;
            --ink:   #2D2B28;
            --muted: #6B655D;
            --slate: #A89B7A;
            --rule:  #E8E6E1;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: var(--bg);
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
        }
        canvas { display: block; }
        #hint {
            position: fixed;
            bottom: 28px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Inter', sans-serif;
            font-size: 11px;
            font-weight: 400;
            letter-spacing: 0.1em;
            color: var(--slate);
            opacity: 0.7;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="hint">drag to orbit &nbsp;·&nbsp; scroll to zoom</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Design tokens — mirrored from index.html
        const BG    = 0xFAF9F6;
        const INK   = 0x2D2B28;
        const SLATE = 0xA89B7A;
        const RULE  = 0xE8E6E1;

        // ── Scene ────────────────────────────────────────────────
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(BG);
        scene.fog = new THREE.Fog(BG, 18, 36);

        const camera = new THREE.PerspectiveCamera(48, innerWidth / innerHeight, 0.1, 100);
        camera.position.set(0, 1.5, 11);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // ── Controls ─────────────────────────────────────────────
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.06;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.35;
        controls.minDistance = 4;
        controls.maxDistance = 22;

        // ── Lights — warm, diffuse, no drama ─────────────────────
        // High ambient fills the scene with warm paper light
        scene.add(new THREE.AmbientLight(0xfaf9f6, 0.85));

        // Soft key light from upper right
        const key = new THREE.DirectionalLight(0xfff8ee, 0.55);
        key.position.set(5, 8, 4);
        key.castShadow = true;
        key.shadow.mapSize.width  = 1024;
        key.shadow.mapSize.height = 1024;
        key.shadow.camera.near = 0.5;
        key.shadow.camera.far  = 30;
        scene.add(key);

        // Warm fill from lower left — softens shadows
        const fill = new THREE.DirectionalLight(0xf0ece4, 0.3);
        fill.position.set(-4, -3, 3);
        scene.add(fill);

        // Subtle slate accent light for depth on the far side
        const accent = new THREE.DirectionalLight(0xc8bba6, 0.2);
        accent.position.set(0, -2, -6);
        scene.add(accent);

        // ── Node definitions ─────────────────────────────────────
        const NODE_DATA = [
            {
                id: 'center',
                lines: ['PRZNT', 'AI'],
                color: INK,
                pos: [0, 0, 0],
                type: 'sphere',
                rx: 1.12, ry: 0.75, rz: 1.12,
                isCenter: true,
            },
            {
                id: 'voice',
                lines: ['My Voice'],
                color: 0xd4764a,
                pos: [-2.2, 2.6, 0.7],
                type: 'sphere',
                rx: 0.88, ry: 0.52, rz: 0.88,
            },
            {
                id: 'mission',
                lines: ['Know my', 'mission'],
                color: 0x4a7fd4,
                pos: [2.6, 2.5, -0.7],
                type: 'sphere',
                rx: 1.05, ry: 0.52, rz: 1.05,
            },
            {
                id: 'research',
                lines: ['Do deep research', 'for specialized', 'tasks'],
                color: 0x3d9e82,
                pos: [-3.2, 0.1, 1.1],
                type: 'sphere',
                rx: 0.94, ry: 0.94, rz: 0.94,
            },
            {
                id: 'creative',
                lines: ['Be uniquely', 'creative'],
                color: 0x9a5ec8,
                pos: [3.2, 0.2, -1.0],
                type: 'sphere',
                rx: 0.90, ry: 0.55, rz: 0.90,
            },
            {
                id: 'works',
                lines: ['Works while', 'I think'],
                color: 0x5dad6a,
                pos: [-2.4, -2.6, 0.6],
                type: 'sphere',
                rx: 1.0, ry: 0.58, rz: 1.0,
            },
            {
                id: 'improve',
                lines: ['Meaningfully improve', 'my productivity'],
                color: 0xc4963a,
                pos: [0.1, -3.0, -0.6],
                type: 'hex',
                rx: 1.1, ry: 0.42, rz: 0.7,
            },
            {
                id: 'teach',
                lines: ['Teach me so I', 'can do it alone'],
                color: 0xc44b84,
                pos: [2.8, -2.4, 0.9],
                type: 'box',
                rx: 1.5, ry: 0.55, rz: 0.5,
            },
        ];

        // ── Canvas label texture ──────────────────────────────────
        // Center: white text on dark node
        // Satellites: ink text on warm background — matches site typography
        function makeLabel(lines, isCenter) {
            const W = 320;
            const H = lines.length > 2 ? 100 : 76;
            const canvas = document.createElement('canvas');
            canvas.width = W; canvas.height = H;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, W, H);

            const fontSize   = isCenter ? 17 : 13;
            const fontWeight = isCenter ? '600' : '500';
            const fontFace   = "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";

            ctx.textAlign    = 'center';
            ctx.textBaseline = 'middle';

            if (isCenter) {
                // White on dark — high contrast
                ctx.fillStyle  = 'rgba(250,249,246,0.96)';
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur  = 6;
            } else {
                // Ink on warm white — matches site body text
                ctx.fillStyle  = '#2D2B28';
                ctx.shadowColor = 'rgba(250,249,246,0.8)';
                ctx.shadowBlur  = 4;
            }

            const lh = fontSize * 1.55;
            const totalH = lines.length * lh;

            lines.forEach((line, i) => {
                const y = H / 2 - totalH / 2 + lh * i + lh / 2;
                if (isCenter && i === 1) {
                    // "AI" sub-label — muted, tracked out
                    ctx.font        = `400 10px ${fontFace}`;
                    ctx.globalAlpha = 0.5;
                } else {
                    ctx.font = `${fontWeight} ${fontSize}px ${fontFace}`;
                }
                ctx.fillText(line, W / 2, y);
                ctx.globalAlpha = 1;
            });

            return new THREE.CanvasTexture(canvas);
        }

        // ── Build nodes ───────────────────────────────────────────
        const nodeMeshes = [];

        NODE_DATA.forEach((data, i) => {
            let geo;
            if (data.type === 'sphere') {
                geo = new THREE.SphereGeometry(1, 40, 24);
            } else if (data.type === 'hex') {
                geo = new THREE.CylinderGeometry(1, 1, 1, 6, 1);
            } else {
                geo = new THREE.BoxGeometry(1, 1, 1, 1, 1, 1);
            }

            // Matte, paper-like material — no glow, restrained
            const mat = new THREE.MeshStandardMaterial({
                color:            data.color,
                emissive:         data.color,
                emissiveIntensity: data.isCenter ? 0.04 : 0.06,
                roughness:        0.6,
                metalness:        0.04,
            });

            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(...data.pos);
            mesh.scale.set(data.rx, data.ry, data.rz);
            mesh.castShadow    = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Label sprite — child of mesh so it bobs in sync
            const tex      = makeLabel(data.lines, data.isCenter);
            const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
            const sprite   = new THREE.Sprite(spriteMat);

            const labelW = data.isCenter ? 1.5 : data.lines.length > 2 ? 2.8 : 2.2;
            const labelH = data.isCenter ? 0.5  : data.lines.length > 2 ? 0.72 : 0.52;
            sprite.scale.set(labelW, labelH, 1);

            const offset = data.isCenter ? 0 : -(data.ry + 0.52);
            sprite.position.set(0, offset / data.ry, 0);
            mesh.add(sprite);

            nodeMeshes.push({ mesh, data, baseY: data.pos[1], phase: i * 1.1 });
        });

        // ── Connections ───────────────────────────────────────────
        const midOffsets = [
            null,
            [-0.4,  0.3,  0.3],
            [ 0.5,  0.3, -0.2],
            [-0.5,  0.1,  0.4],
            [ 0.5,  0.1, -0.3],
            [-0.3, -0.4,  0.2],
            [ 0.0, -0.5, -0.2],
            [ 0.4, -0.3,  0.3],
        ];

        NODE_DATA.forEach((data, i) => {
            if (data.isCenter) return;

            const start = new THREE.Vector3(0, 0, 0);
            const end   = new THREE.Vector3(...data.pos);
            const [ox, oy, oz] = midOffsets[i];
            const mid = start.clone().lerp(end, 0.5).add(new THREE.Vector3(ox, oy, oz));

            const curve   = new THREE.QuadraticBezierCurve3(start, mid, end);
            const tubeGeo = new THREE.TubeGeometry(curve, 24, 0.025, 6, false);

            // Tubes: node color at low opacity — reads as delicate lines on warm bg
            const tubeMat = new THREE.MeshStandardMaterial({
                color:       data.color,
                transparent: true,
                opacity:     0.35,
                roughness:   0.7,
            });
            scene.add(new THREE.Mesh(tubeGeo, tubeMat));

            // Junction dot
            const dot = new THREE.Mesh(
                new THREE.SphereGeometry(0.055, 10, 10),
                new THREE.MeshStandardMaterial({ color: data.color, roughness: 0.5 })
            );
            dot.position.copy(end);
            scene.add(dot);
        });

        // ── Slate dust particles ──────────────────────────────────
        // Very faint — texture, not spectacle
        const pCount = 240;
        const pPos   = new Float32Array(pCount * 3);
        for (let i = 0; i < pCount; i++) {
            const r     = 7 + Math.random() * 8;
            const theta = Math.random() * Math.PI * 2;
            const phi   = Math.acos(2 * Math.random() - 1);
            pPos[i * 3]     = r * Math.sin(phi) * Math.cos(theta);
            pPos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            pPos[i * 3 + 2] = r * Math.cos(phi);
        }
        const pGeo = new THREE.BufferGeometry();
        pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        const pMat = new THREE.PointsMaterial({
            color:       SLATE,
            size:        0.05,
            transparent: true,
            opacity:     0.18,
        });
        const particles = new THREE.Points(pGeo, pMat);
        scene.add(particles);

        // ── Resize ────────────────────────────────────────────────
        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });

        // ── Animate ───────────────────────────────────────────────
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            // Gentle float — quiet, not bouncy
            nodeMeshes.forEach(({ mesh, data, baseY, phase }) => {
                if (!data.isCenter) {
                    mesh.position.y = baseY + Math.sin(t * 0.5 + phase) * 0.11;
                }
            });

            // Very slow particle drift
            particles.rotation.y = t * 0.012;
            particles.rotation.x = t * 0.006;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
