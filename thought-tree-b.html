<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thought Tree B — 3D Cards</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg:    #FAF9F6;
            --ink:   #2D2B28;
            --muted: #6B655D;
            --slate: #A89B7A;
            --rule:  #E8E6E1;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: var(--bg); overflow: hidden; -webkit-font-smoothing: antialiased; }
        canvas { display: block; }

        #hint {
            position: fixed;
            bottom: 28px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Inter', sans-serif;
            font-size: 11px;
            font-weight: 400;
            letter-spacing: 0.1em;
            color: var(--slate);
            opacity: 0.7;
            pointer-events: none;
            z-index: 20;
        }
        #vignette {
            position: fixed;
            inset: 0;
            background: radial-gradient(
                ellipse 80% 80% at 50% 50%,
                transparent 35%,
                rgba(250, 249, 246, 0.55) 70%,
                rgba(250, 249, 246, 0.92) 100%
            );
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="vignette"></div>
    <div id="hint">drag to orbit &nbsp;·&nbsp; scroll to zoom</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        const BG    = 0xFAF9F6;
        const INK   = 0x2D2B28;
        const SLATE = 0xA89B7A;

        // ── Canvas helpers ────────────────────────────────────────
        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function hexToCSS(hex) {
            return '#' + hex.toString(16).padStart(6, '0');
        }

        function makeCard(lines, color, isCenter) {
            const W = 512;
            const lh = 30;
            const pad = 18;
            const barW = 10;
            const H = isCenter ? 88 : (pad * 2 + lines.length * lh);
            const canvas = document.createElement('canvas');
            canvas.width = W;
            canvas.height = H;
            const ctx = canvas.getContext('2d');

            // Drop shadow
            ctx.shadowColor  = 'rgba(45, 43, 40, 0.12)';
            ctx.shadowBlur   = 16;
            ctx.shadowOffsetY = 4;

            // Card background
            ctx.fillStyle = '#FAF9F6';
            roundRect(ctx, 0, 0, W, H, 14);
            ctx.fill();

            // Reset shadow before bar + border
            ctx.shadowColor = 'transparent';

            // Colored left bar
            ctx.fillStyle = hexToCSS(color);
            roundRect(ctx, 0, 0, barW + 4, H, [14, 0, 0, 14]);
            ctx.fill();
            ctx.fillRect(barW, 0, 4, H);

            // Subtle border
            ctx.strokeStyle = '#E8E6E1';
            ctx.lineWidth = 1.5;
            roundRect(ctx, 1, 1, W - 2, H - 2, 13);
            ctx.stroke();

            // Text
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'left';

            if (isCenter) {
                // "YOU" — large, lettertracked, ink
                ctx.fillStyle = '#2D2B28';
                ctx.font = '300 44px Inter, -apple-system, sans-serif';
                ctx.letterSpacing = '0.12em';
                ctx.fillText('YOU', barW + 20, H / 2 + 2);
            } else {
                ctx.fillStyle = '#2D2B28';
                lines.forEach((line, i) => {
                    ctx.font = i === 0
                        ? '600 20px Inter, -apple-system, sans-serif'
                        : '400 18px Inter, -apple-system, sans-serif';
                    ctx.fillStyle = i === 0 ? '#2D2B28' : '#6B655D';
                    ctx.fillText(line, barW + 18, pad + lh * i + lh / 2);
                });
            }

            return new THREE.CanvasTexture(canvas);
        }

        // ── Scene ─────────────────────────────────────────────────
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(BG);
        scene.fog = new THREE.Fog(BG, 18, 36);

        const camera = new THREE.PerspectiveCamera(48, innerWidth / innerHeight, 0.1, 100);
        camera.position.set(0, 1.5, 8.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // ── Controls ──────────────────────────────────────────────
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.06;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.35;
        controls.minDistance = 4;
        controls.maxDistance = 22;

        // ── Lights ────────────────────────────────────────────────
        scene.add(new THREE.AmbientLight(0xfaf9f6, 0.85));
        const key = new THREE.DirectionalLight(0xfff8ee, 0.55);
        key.position.set(5, 8, 4);
        key.castShadow = true;
        key.shadow.mapSize.width  = 1024;
        key.shadow.mapSize.height = 1024;
        key.shadow.camera.near = 0.5;
        key.shadow.camera.far  = 30;
        scene.add(key);
        const fill = new THREE.DirectionalLight(0xf0ece4, 0.3);
        fill.position.set(-4, -3, 3);
        scene.add(fill);
        const accent = new THREE.DirectionalLight(0xc8bba6, 0.2);
        accent.position.set(0, -2, -6);
        scene.add(accent);

        // ── Node definitions ──────────────────────────────────────
        const NODE_DATA = [
            { id: 'center',   lines: ['YOU'],                                   color: SLATE,    pos: [0, 0, 0],          type: 'sphere', rx: 1.12, ry: 0.75, rz: 1.12, isCenter: true },
            { id: 'voice',    lines: ['My Voice'],                              color: 0xd4764a, pos: [-2.2, 2.6, 0.7],   type: 'sphere', rx: 0.88, ry: 0.52, rz: 0.88 },
            { id: 'mission',  lines: ['Know my', 'mission'],                    color: 0x4a7fd4, pos: [2.6, 2.5, -0.7],   type: 'sphere', rx: 1.05, ry: 0.52, rz: 1.05 },
            { id: 'research', lines: ['Deep research', 'for specialized tasks'],color: 0x3d9e82, pos: [-3.2, 0.1, 1.1],   type: 'sphere', rx: 0.94, ry: 0.94, rz: 0.94 },
            { id: 'creative', lines: ['Be uniquely', 'creative'],               color: 0x9a5ec8, pos: [3.2, 0.2, -1.0],   type: 'sphere', rx: 0.90, ry: 0.55, rz: 0.90 },
            { id: 'works',    lines: ['Works while', 'I think'],                color: 0x5dad6a, pos: [-2.4, -2.6, 0.6],  type: 'sphere', rx: 1.0,  ry: 0.58, rz: 1.0  },
            { id: 'improve',  lines: ['Meaningfully improve', 'productivity'],  color: 0xc4963a, pos: [0.1, -3.0, -0.6],  type: 'hex',    rx: 1.1,  ry: 0.42, rz: 0.7  },
            { id: 'teach',    lines: ['Teach me so I', 'can do it alone'],      color: 0xc44b84, pos: [2.8, -2.4, 0.9],   type: 'box',    rx: 1.5,  ry: 0.55, rz: 0.5  },
        ];

        // ── Build nodes + card panels ─────────────────────────────
        const nodeMeshes  = [];
        const cardPlanes  = [];

        // Wait for fonts before building canvas textures
        document.fonts.ready.then(() => {
            NODE_DATA.forEach((data, i) => {
                // ── Sphere / geometry ──
                let geo;
                if (data.type === 'sphere') geo = new THREE.SphereGeometry(1, 40, 24);
                else if (data.type === 'hex') geo = new THREE.CylinderGeometry(1, 1, 1, 6, 1);
                else geo = new THREE.BoxGeometry(1, 1, 1, 1, 1, 1);

                const mat = new THREE.MeshStandardMaterial({
                    color:             data.color,
                    emissive:          data.color,
                    emissiveIntensity: data.isCenter ? 0.04 : 0.06,
                    roughness:         0.6,
                    metalness:         0.04,
                });

                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(...data.pos);
                mesh.scale.set(data.rx, data.ry, data.rz);
                mesh.castShadow    = true;
                mesh.receiveShadow = true;
                scene.add(mesh);

                // ── Card panel ──
                // World width: 2.4 units for satellite, 1.6 for center
                const cardW = data.isCenter ? 1.6 : 2.4;
                const lines = data.lines;
                const lh = 30;
                const padH = 18;
                const cardHpx = data.isCenter ? 88 : (padH * 2 + lines.length * lh);
                // Keep card aspect ratio matching texture (512 × cardHpx)
                const cardH = cardW * (cardHpx / 512);

                const cardGeo = new THREE.PlaneGeometry(cardW, cardH);
                const cardTex = makeCard(data.lines, data.color, data.isCenter);
                const cardMat = new THREE.MeshBasicMaterial({
                    map: cardTex,
                    transparent: true,
                    depthWrite: false,
                    side: THREE.DoubleSide,
                });
                const card = new THREE.Mesh(cardGeo, cardMat);

                // Position card above or to the side of node
                if (data.isCenter) {
                    // Above center sphere
                    card.position.set(data.pos[0], data.pos[1] + data.ry * 1.1 + cardH / 2 + 0.15, data.pos[2]);
                } else {
                    // Offset away from center, slightly above node equator
                    const dir = new THREE.Vector3(...data.pos).normalize();
                    const radialPush = Math.max(data.rx, data.rz) * 0.7;
                    card.position.set(
                        data.pos[0] + dir.x * radialPush,
                        data.pos[1] + data.ry + cardH / 2 + 0.2,
                        data.pos[2] + dir.z * radialPush
                    );
                }

                scene.add(card);
                cardPlanes.push(card);
                nodeMeshes.push({ mesh, data, baseY: data.pos[1], phase: i * 1.1, card });
            });

            buildConnections();
            buildParticles();
            animate();
        });

        function buildConnections() {
            const midOffsets = [
                null,
                [-0.4,  0.3,  0.3],
                [ 0.5,  0.3, -0.2],
                [-0.5,  0.1,  0.4],
                [ 0.5,  0.1, -0.3],
                [-0.3, -0.4,  0.2],
                [ 0.0, -0.5, -0.2],
                [ 0.4, -0.3,  0.3],
            ];

            NODE_DATA.forEach((data, i) => {
                if (data.isCenter) return;
                const start = new THREE.Vector3(0, 0, 0);
                const end   = new THREE.Vector3(...data.pos);
                const [ox, oy, oz] = midOffsets[i];
                const mid   = start.clone().lerp(end, 0.5).add(new THREE.Vector3(ox, oy, oz));
                const curve = new THREE.QuadraticBezierCurve3(start, mid, end);
                scene.add(new THREE.Mesh(
                    new THREE.TubeGeometry(curve, 24, 0.025, 6, false),
                    new THREE.MeshStandardMaterial({ color: data.color, transparent: true, opacity: 0.35, roughness: 0.7 })
                ));
                const dot = new THREE.Mesh(
                    new THREE.SphereGeometry(0.055, 10, 10),
                    new THREE.MeshStandardMaterial({ color: data.color, roughness: 0.5 })
                );
                dot.position.copy(end);
                scene.add(dot);
            });
        }

        let particles;
        function buildParticles() {
            const pCount = 240;
            const pPos   = new Float32Array(pCount * 3);
            for (let i = 0; i < pCount; i++) {
                const r     = 7 + Math.random() * 8;
                const theta = Math.random() * Math.PI * 2;
                const phi   = Math.acos(2 * Math.random() - 1);
                pPos[i * 3]     = r * Math.sin(phi) * Math.cos(theta);
                pPos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                pPos[i * 3 + 2] = r * Math.cos(phi);
            }
            const pGeo = new THREE.BufferGeometry();
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            particles = new THREE.Points(pGeo, new THREE.PointsMaterial({
                color: SLATE, size: 0.05, transparent: true, opacity: 0.18,
            }));
            scene.add(particles);
        }

        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });

        // ── Animate ───────────────────────────────────────────────
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            nodeMeshes.forEach(({ mesh, data, baseY, phase, card }) => {
                if (!data.isCenter) {
                    const dy = Math.sin(t * 0.5 + phase) * 0.11;
                    mesh.position.y = baseY + dy;
                    // Card floats with its node
                    if (card) card.position.y += dy - (card.position.y - card.userData.baseCardY || 0);
                }
                // Cards always face camera
                if (card) card.lookAt(camera.position);
            });

            // Store base card Y once
            nodeMeshes.forEach(({ card }) => {
                if (card && card.userData.baseCardY === undefined) {
                    card.userData.baseCardY = card.position.y;
                }
            });

            if (particles) {
                particles.rotation.y = t * 0.012;
                particles.rotation.x = t * 0.006;
            }

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
