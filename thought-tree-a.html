<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thought Tree A — HTML Labels</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg:    #FAF9F6;
            --ink:   #2D2B28;
            --muted: #6B655D;
            --slate: #A89B7A;
            --rule:  #E8E6E1;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: var(--bg); overflow: hidden; -webkit-font-smoothing: antialiased; }
        canvas { display: block; }

        /* ── Label overlay ── */
        #labels { position: fixed; inset: 0; pointer-events: none; }

        .label-chip {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            font-weight: 600;
            line-height: 1.4;
            white-space: nowrap;
            text-shadow:
                0 0 10px rgba(250,249,246,1),
                0 0 20px rgba(250,249,246,0.95),
                0 0 35px rgba(250,249,246,0.7);
            transition: opacity 0.2s ease;
            transform: translate(-50%, -50%);
        }

        .label-center {
            position: absolute;
            font-family: 'Cormorant Garamond', serif;
            font-size: 26px;
            font-weight: 600;
            color: var(--ink);
            letter-spacing: 0.1em;
            white-space: nowrap;
            text-shadow:
                0 0 12px rgba(250,249,246,1),
                0 0 24px rgba(250,249,246,1),
                0 0 40px rgba(250,249,246,0.9);
            transform: translate(-50%, -50%);
            transition: opacity 0.2s ease;
        }

        #hint {
            position: fixed;
            bottom: 28px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Inter', sans-serif;
            font-size: 11px;
            font-weight: 400;
            letter-spacing: 0.1em;
            color: var(--slate);
            opacity: 0.7;
            pointer-events: none;
        }

        #badge {
            position: fixed;
            top: 28px;
            left: 28px;
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            font-weight: 500;
            letter-spacing: 0.15em;
            color: var(--slate);
            text-transform: uppercase;
            opacity: 0.6;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="labels"></div>
    <div id="hint">drag to orbit &nbsp;·&nbsp; scroll to zoom</div>
    <div id="badge">Option A — HTML Labels</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        const BG    = 0xFAF9F6;
        const INK   = 0x2D2B28;
        const SLATE = 0xA89B7A;

        // ── Scene ─────────────────────────────────────────────────
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(BG);
        scene.fog = new THREE.Fog(BG, 18, 36);

        const camera = new THREE.PerspectiveCamera(48, innerWidth / innerHeight, 0.1, 100);
        camera.position.set(0, 1.5, 11);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // ── Controls ──────────────────────────────────────────────
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.06;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.35;
        controls.minDistance = 4;
        controls.maxDistance = 22;

        // ── Lights ────────────────────────────────────────────────
        scene.add(new THREE.AmbientLight(0xfaf9f6, 0.85));
        const key = new THREE.DirectionalLight(0xfff8ee, 0.55);
        key.position.set(5, 8, 4);
        key.castShadow = true;
        key.shadow.mapSize.width  = 1024;
        key.shadow.mapSize.height = 1024;
        key.shadow.camera.near = 0.5;
        key.shadow.camera.far  = 30;
        scene.add(key);
        const fill = new THREE.DirectionalLight(0xf0ece4, 0.3);
        fill.position.set(-4, -3, 3);
        scene.add(fill);
        const accent = new THREE.DirectionalLight(0xc8bba6, 0.2);
        accent.position.set(0, -2, -6);
        scene.add(accent);

        // ── Node definitions ──────────────────────────────────────
        const NODE_DATA = [
            { id: 'center',   lines: ['YOU'],                                   color: INK,      pos: [0, 0, 0],          type: 'sphere', rx: 1.12, ry: 0.75, rz: 1.12, isCenter: true },
            { id: 'voice',    lines: ['My Voice'],                              color: 0xd4764a, pos: [-2.2, 2.6, 0.7],   type: 'sphere', rx: 0.88, ry: 0.52, rz: 0.88 },
            { id: 'mission',  lines: ['Know my', 'mission'],                    color: 0x4a7fd4, pos: [2.6, 2.5, -0.7],   type: 'sphere', rx: 1.05, ry: 0.52, rz: 1.05 },
            { id: 'research', lines: ['Deep research', 'for specialized tasks'],color: 0x3d9e82, pos: [-3.2, 0.1, 1.1],   type: 'sphere', rx: 0.94, ry: 0.94, rz: 0.94 },
            { id: 'creative', lines: ['Be uniquely', 'creative'],               color: 0x9a5ec8, pos: [3.2, 0.2, -1.0],   type: 'sphere', rx: 0.90, ry: 0.55, rz: 0.90 },
            { id: 'works',    lines: ['Works while', 'I think'],                color: 0x5dad6a, pos: [-2.4, -2.6, 0.6],  type: 'sphere', rx: 1.0,  ry: 0.58, rz: 1.0  },
            { id: 'improve',  lines: ['Meaningfully improve', 'productivity'],  color: 0xc4963a, pos: [0.1, -3.0, -0.6],  type: 'hex',    rx: 1.1,  ry: 0.42, rz: 0.7  },
            { id: 'teach',    lines: ['Teach me so I', 'can do it alone'],      color: 0xc44b84, pos: [2.8, -2.4, 0.9],   type: 'box',    rx: 1.5,  ry: 0.55, rz: 0.5  },
        ];

        // ── Build label HTML ──────────────────────────────────────
        const labelsEl = document.getElementById('labels');
        const labelDivs = [];

        NODE_DATA.forEach((data) => {
            let el;
            if (data.isCenter) {
                el = document.createElement('div');
                el.className = 'label-center';
                el.textContent = 'YOU';
            } else {
                el = document.createElement('div');
                el.className = 'label-chip';
                el.style.color = '#' + data.color.toString(16).padStart(6, '0');
                data.lines.forEach((line) => {
                    const s = document.createElement('span');
                    s.textContent = line;
                    el.appendChild(s);
                });
            }
            labelsEl.appendChild(el);
            labelDivs.push(el);
        });

        // ── Build 3D nodes (no sprite labels) ─────────────────────
        const nodeMeshes = [];

        NODE_DATA.forEach((data, i) => {
            let geo;
            if (data.type === 'sphere') geo = new THREE.SphereGeometry(1, 40, 24);
            else if (data.type === 'hex') geo = new THREE.CylinderGeometry(1, 1, 1, 6, 1);
            else geo = new THREE.BoxGeometry(1, 1, 1, 1, 1, 1);

            // Clear inner sphere — faint tinted wash
            const mat = new THREE.MeshStandardMaterial({
                color:       data.color,
                transparent: true,
                opacity:     0.10,
                roughness:   0.15,
                metalness:   0.0,
            });

            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(...data.pos);
            mesh.scale.set(data.rx, data.ry, data.rz);
            mesh.castShadow    = false;
            mesh.receiveShadow = false;
            scene.add(mesh);

            // Colored border: back-face-only outline sphere
            const outlineScale = data.isCenter ? 1.09 : 1.07;
            const outlineMesh  = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({
                color: data.color,
                side:  THREE.BackSide,
            }));
            outlineMesh.scale.setScalar(outlineScale);
            mesh.add(outlineMesh);

            nodeMeshes.push({ mesh, data, baseY: data.pos[1], phase: i * 1.1 });
        });

        // ── Connections ───────────────────────────────────────────
        const midOffsets = [
            null,
            [-0.4,  0.3,  0.3],
            [ 0.5,  0.3, -0.2],
            [-0.5,  0.1,  0.4],
            [ 0.5,  0.1, -0.3],
            [-0.3, -0.4,  0.2],
            [ 0.0, -0.5, -0.2],
            [ 0.4, -0.3,  0.3],
        ];

        NODE_DATA.forEach((data, i) => {
            if (data.isCenter) return;
            const start = new THREE.Vector3(0, 0, 0);
            const end   = new THREE.Vector3(...data.pos);
            const [ox, oy, oz] = midOffsets[i];
            const mid   = start.clone().lerp(end, 0.5).add(new THREE.Vector3(ox, oy, oz));
            const curve = new THREE.QuadraticBezierCurve3(start, mid, end);
            const tubeGeo = new THREE.TubeGeometry(curve, 24, 0.025, 6, false);
            scene.add(new THREE.Mesh(tubeGeo, new THREE.MeshStandardMaterial({
                color: data.color, transparent: true, opacity: 0.28, roughness: 0.7,
            })));
            const dot = new THREE.Mesh(
                new THREE.SphereGeometry(0.055, 10, 10),
                new THREE.MeshStandardMaterial({ color: data.color, roughness: 0.5 })
            );
            dot.position.copy(end);
            scene.add(dot);
        });

        // ── Particles ─────────────────────────────────────────────
        const pCount = 240;
        const pPos   = new Float32Array(pCount * 3);
        for (let i = 0; i < pCount; i++) {
            const r     = 7 + Math.random() * 8;
            const theta = Math.random() * Math.PI * 2;
            const phi   = Math.acos(2 * Math.random() - 1);
            pPos[i * 3]     = r * Math.sin(phi) * Math.cos(theta);
            pPos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            pPos[i * 3 + 2] = r * Math.cos(phi);
        }
        const pGeo = new THREE.BufferGeometry();
        pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        const particles = new THREE.Points(pGeo, new THREE.PointsMaterial({
            color: SLATE, size: 0.05, transparent: true, opacity: 0.18,
        }));
        scene.add(particles);

        // ── Resize ────────────────────────────────────────────────
        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });

        // ── Project 3D → screen ───────────────────────────────────
        const _v = new THREE.Vector3();

        function updateLabels() {
            nodeMeshes.forEach(({ mesh, data }, i) => {
                const div = labelDivs[i];

                // Get world position
                _v.setFromMatrixPosition(mesh.matrixWorld);
                _v.project(camera);

                const behindCamera = _v.z > 1;
                const x = ( _v.x * 0.5 + 0.5) * innerWidth;
                const y = (-_v.y * 0.5 + 0.5) * innerHeight;

                div.style.left    = x + 'px';
                div.style.top     = y + 'px';
                div.style.opacity = behindCamera ? '0' : '1';
            });
        }

        // ── Animate ───────────────────────────────────────────────
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            nodeMeshes.forEach(({ mesh, data, baseY, phase }) => {
                if (!data.isCenter) {
                    mesh.position.y = baseY + Math.sin(t * 0.5 + phase) * 0.11;
                }
            });

            particles.rotation.y = t * 0.012;
            particles.rotation.x = t * 0.006;

            controls.update();
            renderer.render(scene, camera);
            updateLabels();
        }

        animate();
    </script>
</body>
</html>
